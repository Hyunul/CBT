<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CBT Load Test Report: Kafka vs Sync</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body { font-family: sans-serif; padding: 20px; max-width: 800px; margin: 0 auto; }
        h1 { text-align: center; }
        .chart-container { margin-bottom: 50px; }
        table { width: 100%; border-collapse: collapse; margin-top: 20px; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: center; }
        th { background-color: #f2f2f2; }
    </style>
</head>
<body>
    <h1>Kafka vs Sync 성능 비교</h1>
    
    <div class="chart-container">
        <canvas id="tpsChart"></canvas>
    </div>
    <div class="chart-container">
        <canvas id="latencyChart"></canvas>
    </div>

    <h2>상세 데이터</h2>
    <table id="dataTable">
        <thead>
            <tr>
                <th>지표</th>
                <th>Kafka (Async)</th>
                <th>Sync (Direct)</th>
                <th>차이</th>
            </tr>
        </thead>
        <tbody></tbody>
    </table>

    <script>
        // Load data from JSON files (assuming they are in the same directory or fetched)
        // For this static HTML, we will inject the data read from the files.
        
        // PLACEHOLDER_DATA_START
        const asyncData = {
            tps: 57.26, 
            p95: 61.27,
            avg: 41.56,
            max: 6880
        };
        const syncData = {
            tps: 57.55,
            p95: 66.15,
            avg: 36.95,
            max: 6870
        };
        // PLACEHOLDER_DATA_END

        const ctxTPS = document.getElementById('tpsChart').getContext('2d');
        new Chart(ctxTPS, {
            type: 'bar',
            data: {
                labels: ['TPS (초당 처리량)'],
                datasets: [
                    { label: 'Kafka (Async)', data: [asyncData.tps], backgroundColor: 'rgba(54, 162, 235, 0.6)' },
                    { label: 'Sync (Direct)', data: [syncData.tps], backgroundColor: 'rgba(255, 99, 132, 0.6)' }
                ]
            },
            options: { scales: { y: { beginAtZero: true, title: { display: true, text: 'Req/s' } } } }
        });

        const ctxLatency = document.getElementById('latencyChart').getContext('2d');
        new Chart(ctxLatency, {
            type: 'bar',
            data: {
                labels: ['평균 응답속도 (Avg)', 'P95 응답속도 (상위 5% 지연)'],
                datasets: [
                    { label: 'Kafka (Async)', data: [asyncData.avg, asyncData.p95], backgroundColor: 'rgba(54, 162, 235, 0.6)' },
                    { label: 'Sync (Direct)', data: [syncData.avg, syncData.p95], backgroundColor: 'rgba(255, 99, 132, 0.6)' }
                ]
            },
            options: { scales: { y: { beginAtZero: true, title: { display: true, text: 'ms (낮을수록 좋음)' } } } }
        });

        // Table population
        const tbody = document.querySelector('#dataTable tbody');
        const metrics = [
            { key: 'tps', label: 'TPS (Req/s)' },
            { key: 'avg', label: '평균 응답속도 (ms)' },
            { key: 'p95', label: 'P95 응답속도 (ms)' },
            { key: 'max', label: '최대 응답속도 (ms)' }
        ];

        metrics.forEach(m => {
            const row = tbody.insertRow();
            const valAsync = asyncData[m.key];
            const valSync = syncData[m.key];
            const diff = valAsync - valSync;
            const diffStr = diff > 0 ? `+${diff.toFixed(2)}` : diff.toFixed(2);
            
            row.insertCell().textContent = m.label;
            row.insertCell().textContent = valAsync.toFixed(2);
            row.insertCell().textContent = valSync.toFixed(2);
            row.insertCell().textContent = diffStr;
        });
    </script>
</body>
</html>
